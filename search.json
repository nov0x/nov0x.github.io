[{"title":"黑马点评_Redis学习案例","path":"/2022/11/30/黑马点评-Redis学习案例/","content":"# 导入项目\n\n\n1. 在虚拟机上安装redis并启动\n2. idea中导入后端相关代码\n3. MySQL中导入相关数据\n\n启动后端项目，访问localhost:8081/shop-type/list。显示数据\n\n4. 启动nginx部署前端\n- 只需要将nginx压缩包解压，进入文件夹用终端打开输入start nginx.exe即可启动nginx\n- 启动nginx后访问localhost:8080检查是否运行正常\n\n# 基于session的短信登录\n\n## 发送验证码\n>由于其他部分已经完成，现在只需要创建对应的方法\n- userServiceImpl中创建方法\n```java\n@Override  \npublic Result sendCoed(String phone, HttpSession session) {  \n    //使用正则表达式，校验手机号码是否正确  \n    if (RegexUtils.isPhoneInvalid(phone)) {  \n        return Result.fail(\"手机号输入有误,请重新输入\");  \n    }  \n    //使用工具类生成验证码  \n    String code = RandomUtil.randomNumbers(6);  \n    //将验证码保存到session  \n    session.setAttribute(\"code\",code);  \n    //发送验证码，(模拟发送)  \n    log.debug(\"发送的验证码是===\"+code);  \n    return Result.ok();  \n}\n```\n\n## 用户登录，以及注册\n\n```java\n@Override  \npublic Result login(LoginFormDTO loginForm, HttpSession session) {  \n    //再次校验手机号  \n    String phone = loginForm.getPhone();  \n    if (RegexUtils.isPhoneInvalid(phone)){  \n        return  Result.fail(\"手机号有误\");  \n    }  \n    //校验验证码  \n    String code =(String) session.getAttribute(\"code\");  \n    //这里先判断错误，可以避免在if中出现多层代码嵌套  \n    if (null==session || !loginForm.getCode().equals(code)){  \n       return  Result.fail(\"验证码错误！！\");  \n    }  \n    //根据手机号查询用户是否已注册过，未注册则进行注册  \n    //query是mybatisPlus提供的  \n    User usr = query().eq(\"phone\", phone).one();  \n    if (null==usr){  \n       usr = createUsr(phone);  \n    }  \n    session.setAttribute(\"user\",usr);  \n  \n    return Result.ok();  \n}  \n  \n/**  \n * 创建用户  \n * @param phone  \n * @return  \n */  \nprivate User createUsr(String phone) {  \n    User user = new User();  \n    user.setPhone(phone);  \n    user.setNickName(SystemConstants.USER_NICK_NAME_PREFIX +RandomUtil.randomString(5));  \n    save(user);  \n    return user;  \n}\n```\n\n## 登录校验拦截器\n- 对未登录的用户进行功能限制\n\n1. 创建拦截器：\n创建类实现==HandlerInterceptor==方法\n\n```java\n@Component  \npublic class LoginInterceptor implements HandlerInterceptor {  \n    @Override  \n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {  \n        //从session中查看用户是否存在  \n       Object user = request.getSession().getAttribute(\"user\");  \n        if (null==user){  \n            response.setStatus(2233);  \n            return  false;        }  \n        //若用户存在则保存到ThreadLocal，  \n        UserHolder.saveUser((UserDTO) user);  \n        return  true;    }  \n  \n    @Override  \n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {  \n        HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);  \n    }  \n  \n    @Override  \n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {  \n        HandlerInterceptor.super.afterCompletion(request, response, handler, ex);  \n    }  \n}\n```\n\n2. 创建springMvc配置类实现==WebMvcConfigurer==或继承====WebMvcConfigurationSupport==，==addInterceptors==方法添加拦截器\n\n在spring中配置WebMvc时有两种方法，一种是继承WebMvcConfigurationSupport，[重写](https://so.csdn.net/so/search?q=%E9%87%8D%E5%86%99&spm=1001.2101.3001.7020)里面相应的方法，还有一种是继承WebMvcConfigurer的子抽象类WebMvcConfigurerAdapter，也是重写里面相应的方法，但是需要在配置类上添加@EnableWebMvc注解。那这两个类直接是什么关系呢？  \nWebMvcConfigurationSupport中那些子类可以重写的空方法在[WebMvcConfigurer](https://so.csdn.net/so/search?q=WebMvcConfigurer&spm=1001.2101.3001.7020)都有，这说明WebMvcConfigurer只是WebMvcConfigurationSupport的一个扩展类，它并没有扩展新功能，只是为让用户更方便安全的添加自定义配置，为什么说是安全呢？因为如果直接继承WebMvcConfigurationSupport，那么用户可以重写默认的配置，如果对原理不是很清楚地开发者不小心重写了默认的配置，springmvc可能相关功能就无法生效，是一种不安全的行为。但如果是继承WebMvcConfigurerAdapter，那么开发者是在默认配置的基础上添加自定义配置，相对来说更安全一些，只不过要多加一个@EnableWebMvc注解。从这个角度来说，最佳实践还是继承WebMvcConfigurerAdapter\n\n```java\n@Configuration  \npublic class WebMvcConfig implements WebMvcConfigurer {  \n    @Autowired  \n    private LoginInterceptor loginInterceptor;  \n  \n  \n    @Override  \n    public void addInterceptors(InterceptorRegistry registry) {  \n        registry.addInterceptor(loginInterceptor).excludePathPatterns(  \n                               //需要放行的请求  \n               \"/shop/**\",  \n               \"/voucher/**\",  \n               \"/shop-type/**\",  \n               \"/upload/**\",  \n               \"/blog/hot\",  \n               \"/user/code\",  \n               \"/user/login\"  \n        );  \n    }  \n}\n```\n\n## 返回数据优化\n- 原先session保存的用户数据中包含了密码手机号等，隐私信息不安全，同时多占用了内存\n- 改为使用userDTO，返回需要的数据\n\n```java\n@Data  \npublic class UserDTO {  \n    private Long id;  \n    private String nickName;  \n    private String icon;  \n}\n```\n\n- BeanUtil.copyProperties()，是hutool提供一个拷贝数据的方法\n```java\nUserDTO userDTO = new UserDTO();  \nsession.setAttribute(\"user\",  \nBeanUtil.copyProperties(usr,UserDTO.class,\"password\",\"phone\",\"create_time\",\"update_time\"));  \nreturn Result.ok();\n```\n\n\n# token验证\n\n[Token登录认证 - 简书 (jianshu.com)](https://www.jianshu.com/p/a32634a5170c)\n\n# 基于redis的短信登录\n\n## 集群session的共享问题\n- 多台tomcat并不共享session储存空间，当切换到不同服务器是会造成数据丢失\n- 存储数据时使用手机号码作为key，保证数据的唯一性，之前储存在session中统一使用字符串“code”作为key是因为每个浏览器携带的session都是不同的，现在使用redis作为统一的存储空间，需要保证唯一性\n\n\n## 发送验证码\n\n\n```java\n    public Result sendCoed(String phone, HttpSession session) {  \n        //使用正则表达式，校验手机号码是否正确  \n        if (RegexUtils.isPhoneInvalid(phone)) {  \n            return Result.fail(\"手机号输入有误,请重新输入\");  \n        }  \n        //使用工具类生成验证码  \n        String code = RandomUtil.randomNumbers(6);  \n        //将验证码保存到session  \n//        session.setAttribute(\"code\",code);  \n        //将验证码改为保存到redis中  手机号码作为key，并设置为1分钟的过期时间  \n        stringRedisTemplate.opsForValue().set(LoginConstants.LOGIN_CODE+phone,code,LoginConstants.CODE_TTL, TimeUnit.MINUTES);  \n        //发送验证码，(模拟发送)  \n        log.debug(\"发送的验证码是===\"+code);  \n        return Result.ok();  \n    }\n\n```\n\n\n## 登录\n```java\n  public Result login(LoginFormDTO loginForm, HttpSession session) {  \n        //再次校验手机号  \n        String phone = loginForm.getPhone();  \n        if (RegexUtils.isPhoneInvalid(phone)){  \n            return  Result.fail(\"手机号有误\");  \n        }  \n//        //校验验证码  \n//        String code =(String) session.getAttribute(\"code\");  \n        //改为从redis获取保存的验证码  \n        String  code = stringRedisTemplate.opsForValue().get(LoginConstants.LOGIN_CODE + phone);  \n        //这里先判断错误，可以避免在if中出现多层代码嵌套  \n        if (null==session || !loginForm.getCode().equals(code)){  \n           return  Result.fail(\"验证码错误！！\");  \n        }  \n        //根据手机号查询用户是否已注册过，未注册则进行注册  \n        //query是mybatisPlus提供的  \n        User usr = query().eq(\"phone\", phone).one();  \n        if (null==usr){  \n           usr = createUsr(phone);  \n        }  \n        //生成随机的token(这里简单的使用uuid随机生成)保存，并返回给客户端  \n        String token = UUID.randomUUID().toString(true);  \n//        session.setAttribute(\"user\",  \n//                BeanUtil.copyProperties(usr,UserDTO.class,\"password\",\"phone\",\"create_time\",\"update_time\"));  \n        //将用户信息改为储存到redis中  \n        UserDTO userDTO = BeanUtil.copyProperties(usr, UserDTO.class, \"password\",  \n                \"phone\", \"create_time\", \"update_time\");  \n        //保存到LocalThead中  \n        UserHolder.saveUser(userDTO);  \n        //由于在通过hashMap储存到redis时，StringRedisTemplate只允许储存string类型的字段  \n        //UserDTO的id字段为Long类型会出现错误，可以将数据取出手动进行处理，  \n        // 也可以在 BeanUtil.beanToMap()方法转换时通过CopyOptions.create()，进行相应设置  \n        //setIgnoreNullValue(true)，是否忽略值为空的字段  \n        //setFieldValueEditor(),可以对字段的值进行修改，这里将值修改为字符串类型  \n        Map<String, Object> objectMap =  \n                BeanUtil.beanToMap(  \n                        userDTO,new HashMap<>(),  \n                        CopyOptions.create().setIgnoreNullValue(true).  \n                                setFieldValueEditor((fieldName,fieldValue)->fieldValue.toString())  \n                );  \n  \n        stringRedisTemplate.opsForHash().putAll(LoginConstants.LOGIN_TOKEN+token,objectMap);  \n        //设置token过期时间  \n        stringRedisTemplate.expire(LoginConstants.LOGIN_TOKEN+token,LoginConstants.TOKEN_TTL,TimeUnit.MINUTES);  \n        //返回token  \n        return Result.ok(token);  \n    }\n```\n\n## 拦截器\n```java\n@Component  \npublic class LoginInterceptor implements HandlerInterceptor {  \n    //若没有@Component注解，则该类不会被spring管理不能自动装配StringRedisTemplate，  \n    // 只能使用构造函数来创建StringRedisTemplate  \n    @Autowired  \n    private StringRedisTemplate stringRedisTemplate;  \n  \n    @Override  \n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {  \n        //从session中查看用户是否存在  \n  //     Object user = request.getSession().getAttribute(\"user\");  \n        //获取token验证 ,根据前端将token保存在定义的authorization header中获取  \n        String token = request.getHeader(\"authorization\");  \n        if (StrUtil.isEmpty(token)){  \n            response.setStatus(2233);  \n            return false;        }  \n        //根据token取出数据  \n        Map<Object, Object> entries = stringRedisTemplate.opsForHash().entries(  \n                LoginConstants.LOGIN_TOKEN+token);  \n        if (entries.isEmpty()){  \n            response.setStatus(2233);  \n            return  false;        }  \n        //将map转换为UserDTO  \n        UserDTO user = BeanUtil.fillBeanWithMap(entries,new UserDTO(),false);  \n        //若用户存在则保存到ThreadLocal，  \n        UserHolder.saveUser((UserDTO) user);  \n  \n        //刷新token有效期  \n        stringRedisTemplate.expire(LoginConstants.LOGIN_TOKEN+token,LoginConstants.TOKEN_TTL, TimeUnit.MINUTES);  \n  \n        return  true;    }  \n  \n    @Override  \n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {  \n        HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);  \n    }  \n  \n    @Override  \n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {  \n        HandlerInterceptor.super.afterCompletion(request, response, handler, ex);  \n    }  \n}\n```\n\n根据前端信息，token被保存在自定义的头authorization中\n\n```java\n String token = request.getHeader(\"authorization\");  \n```\n\n\n![image-20221014100338022](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221014.10-03-39.png)\n\n\n\n![image-20221014100358533](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221014.10-03-59.png)\n\n\n\n\n## 登录状态刷新\n\n- 最开始为了在用户一直操作时保持一直登录不退出，在拦截器上进行了过期时间刷新\n```java\n        //刷新token有效期  \n        stringRedisTemplate.expire(LoginConstants.LOGIN_TOKEN+token,LoginConstants.TOKEN_TTL, TimeUnit.MINUTES);  \n```\n\n- 但是这样操作，会导致其他未被拦截的请求。无法触发刷新过期时间，使数据过期，\n- 有可能导致当用户明明一直在进行操作，却还需要再次登录\n\n**解决方法**：\n\n- 再添加一个拦截所有请求的拦截器，\n- 由该拦截器进行获取token并刷新，redis查询用户，以及保存数据到TheadLocal\n- 原来的登录校验拦截器则只进行查询TheadLocal判断有无数据：有放行，无则拦截\n\n\n- 新的拦截所有请求的拦截器\n\n```java\n@Component  \npublic class GlobalInterceptor implements HandlerInterceptor {  \n    //若没有@Component注解，则该类不会被spring管理不能自动装配StringRedisTemplate，  \n    // 只能使用构造函数来创建StringRedisTemplate  \n    @Autowired  \n    private StringRedisTemplate stringRedisTemplate;  \n  \n    @Override  \n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {  \n        //从session中查看用户是否存在  \n  //     Object user = request.getSession().getAttribute(\"user\");  \n        //获取token验证 ,根据前端将token保存在定义的authorization header中获取  \n        String token = request.getHeader(\"authorization\");  \n        if (StrUtil.isEmpty(token)){  \n            return true;  \n        }  \n        //根据token取出数据  \n        Map<Object, Object> entries = stringRedisTemplate.opsForHash().entries(  \n                LoginConstants.LOGIN_TOKEN+token);  \n        if (entries.isEmpty()){  \n          return true;     }  \n        //将map转换为UserDTO  \n        UserDTO user = BeanUtil.fillBeanWithMap(entries,new UserDTO(),false);  \n        //若用户存在则保存到ThreadLocal，  \n        UserHolder.saveUser((UserDTO) user);  \n  \n        //刷新token有效期  \n        stringRedisTemplate.expire(LoginConstants.LOGIN_TOKEN+token,LoginConstants.TOKEN_TTL, TimeUnit.MINUTES);  \n  \n        return  true;    }  \n  \n    @Override  \n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {  \n        HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);  \n    }  \n  \n    @Override  \n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {  \n        HandlerInterceptor.super.afterCompletion(request, response, handler, ex);  \n    }  \n}\n```\n\n\n- 现在的登录拦截器\n```java\n@Component  \npublic class LoginInterceptor implements HandlerInterceptor {  \n  \n  \n    @Override  \n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {  \n        UserDTO user = UserHolder.getUser();  \n        if (null == user) {  \n            response.setStatus(2233);  \n            return false;        }  \n        return true;  \n    }  \n      \n}\n```\n\n\n- 在添加拦截器时还可以设置拦截器的拦截顺序，默认是先添加的先执行，也可以通过==.order()==方法设置值，值越小越先执行\n\n```java\n    @Autowired  \n    private GlobalInterceptor globalInterceptor;  \n  \n    @Override  \n    public void addInterceptors(InterceptorRegistry registry) {  \n        registry.addInterceptor(loginInterceptor).excludePathPatterns(  \n                               //需要放行的请求  \n                \"/shop/**\",  \n                \"/voucher/**\",  \n                \"/shop-type/**\",  \n                \"/upload/**\",  \n                \"/blog/hot\",  \n                \"/user/code\",  \n                \"/user/login\"  \n        ).order(1);  \n        registry.addInterceptor(globalInterceptor).excludePathPatterns().order(0);  \n    }  \n}\n```\n\n# 商户查询缓存\n\n**缓存**数据交换的缓冲区，是储存存储数据的临时地方，读写性能较高\n- 降低后端负载\n- 提高读写效率，降低响应时间\n\n## 添加redis缓存\n\n```java\n@GetMapping(\"/{id}\")  \npublic Result queryShopById(@PathVariable(\"id\") Long id) {  \n  \n    String  info = stringRedisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_KEY + id);  \n    if (StrUtil.isNotBlank(info)){  \n        //存在缓存，则将json字符串转换为bean并返回数据  \n        Shop shop = JSONUtil.toBean(info, Shop.class);  \n        return  Result.ok(shop);  \n    }  \n    Shop shop = shopService.getById(id);  \n  \n    if (null==shop){  \n        return Result.fail(\"数据不存在！！\");  \n    }  \n    //数据存在则写入redis  \n    stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY+id,JSONUtil.toJsonStr(shop));  \n    return Result.ok(shop);  \n}\n```\n\n\n# 缓存更新策略\n\n|          | 内存淘汰                                                     | 超时剔除                                                    | 主动更新                                  |\n| -------- | ------------------------------------------------------------ | ----------------------------------------------------------- | ----------------------------------------- |\n| 说明     | 不用自己维护，利用redis的内存淘汰机制，当内存不足时自动淘汰部分数据下次查询时更新缓存 | 给缓存数据添加ttl时间到期后自动删除缓存，下次查询时更新缓存 | 编写业务逻辑，在修改数据库的同时,更新缓存 |\n| 一致性   | 差                                                           | 一般                                                        | 好                                        |\n| 维护成本 | 无                                                           | 低                                                          | 高                                        |\n\n- 在低一致性需求时，可以使用redis自带的内存淘汰机制\n- 在高一致性需求时，主动更新，并同时设置超时时间以免出现错误\n\n**读操作**：\n- 查询到缓存直接返回\n- 未查询到到缓存，则查询数据库，并写入缓存，设置超时时间\n\n**写操作**：\n- 先写数据库，然后再删除缓存\n- 确保数据库与缓存操作的原子性[^atomicity]\n\n\n# 缓存穿透\n\n### 概述\n\n- 我们使用Redis大部分情况都是通过Key查询对应的值，假如发送的请求传进来的key是不存在Redis中的，那么就查不到缓存，查不到缓存就会去数据库查询。假如有大量这样的请求，这些请求像“穿透”了缓存一样直接打在数据库上，这种现象就叫做缓存穿透。\n\n**分析：**\n\n关键在于在Redis查不到key值，这和缓存击穿有根本的区别，区别在于**缓存穿透的情况是传进来的key在Redis中是不存在的**。假如有黑客传进大量的不存在的key，那么大量的请求打在数据库上是很致命的问题，所以在日常开发中要对参数做好校验，一些非法的参数，不可能存在的key就直接返回错误提示，要对调用方保持这种“不信任”的心态。\n\n\n###  解决方案： \n\n1、**把无效的Key存进Redis中（缓存空对象）**。如果Redis查不到数据，数据库也查不到，我们把这个Key值保存进Redis，设置value=\"null\"，当下次再通过这个Key查询时就不需要再查询数据库。这种处理方式肯定是有问题的，假如传进来的这个不存在的Key值每次都是随机的，那存进Redis也没有意义。\n\n![image-20221015113445258](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221015.11-34-46.png)\n\n\n\n2、**使用布隆过滤器**。布隆过滤器的作用是某个 key 不存在，那么就一定不存在，它说某个 key 存在，那么很大可能是存在(存在一定的误判率)。于是我们可以在缓存之前再加一层布隆过滤器，在查询的时候先去布隆过滤器查询 key 是否存在，如果不存在就直接返回。\n\n\n\n![image-20221015113530360](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221015.11-35-31.png)\n\n# 缓存雪崩\n\n### 概述：\n\n**什么是缓存雪崩？**\n\n- 当某一个时刻出现大规模的缓存失效的情况，那么就会导致大量的请求直接打在数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。这时候如果运维马上又重启数据库，马上又会有新的流量把数据库打死。这就是缓存雪崩。\n\n**分析：**\n\n造成缓存雪崩的关键在于在同一时间大规模的key失效。为什么会出现这个问题呢，有几种可能，第一种可能是Redis宕机，第二种可能是采用了相同的过期时间。搞清楚原因之后，那么有什么解决方案呢？\n\n### 解决方案： \n\n1、在原有的失效时间上加上一个随机值，比如1-5分钟随机。这样就避免了因为采用相同的过期时间导致的缓存雪崩。\n\n如果真的发生了缓存雪崩，有没有什么兜底的措施？\n\n2、使用熔断机制。当流量到达一定的阈值时，就直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上。至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。(业务降级限流)\n\n3、提高数据库的容灾能力，可以使用分库分表，读写分离的策略。\n\n4、为了防止Redis宕机导致缓存雪崩的问题，可以搭建Redis集群，提高Redis的容灾性。\n\n\n# 缓存击穿\n\n## 概述：\n\n**什么是缓存击穿？**\n\n其实跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而缓存击穿是一个热点的Key，有大并发集中缓存重建业务较复杂对其进行访问，突然间这个Key失效了，导致大并发全部打在数据库上，导致数据库压力剧增。这种现象就叫做缓存击穿。\n\n**分析：**\n\n关键在于某个热点的key失效了，导致大并发集中打在数据库上。所以要从两个方面解决，第一是否可以考虑热点key不设置过期时间，第二是否可以考虑降低打在数据库上的请求数量。\n\n##  解决方案： \n\n1、**逻辑过期**如果业务允许的话，对于热点的key可以设置永不过期的key。\n- 线程无需等待，性能较好\n- 不保证唯一性\n- 有额外的内存消耗\n- 实现复杂\n\n2、使用**互斥锁**。如果缓存失效的情况，只有拿到锁才可以查询数据库，降低了在同一时刻打在数据库上的请求，防止数据库打死。当然这样会导致系统的性能变差。\n- （没有额外的内存消耗，保证一致性，实现简单）\n- 线程需要等待，性能受影响\n- 可能出现死锁风险\n\n# 基于互斥锁解决缓存击穿\n\n```java\nprivate Shop query_CacheBreakdown(Long id) {  \n  \n  \n    String info = stringRedisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_KEY + id);  \n    //isNotBlank，null,空字符串，转义字符都返回false  \n    if (StrUtil.isNotBlank(info)) {  \n        return JSONUtil.toBean(info, Shop.class);  \n    }  \n    //判断是否未空值  \n    if (info != null) {  \n        return null;  \n    }  \n    //1实现缓存重建  \n    //1.1获取互斥锁  \n    String lockKey = RedisConstants.LOCK_SHOP_KEY + id;  \n    Boolean is_get = getLockKey(lockKey);  \n    Shop shop = null;  \n    try {  \n        //1.2判断是否成功获取  \n        if (!is_get) {  \n            //1.3 获取失败，休眠并重试  \n            Thread.sleep(50);  \n            return query_CachePassThrough(id);  \n        }  \n        //获取锁成功后再次检查缓存是否存在  \n        info = stringRedisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_KEY + id);  \n        if (StrUtil.isNotBlank(info)) {  \n            return JSONUtil.toBean(info, Shop.class);  \n        }  \n        if (info != null) {  \n            return null;  \n        }  \n        //1.4 获取成功，根据id查询数据库  \n        shop = getById(id);  \n  \n        //模拟构建延时  \n        Thread.sleep(200);  \n        if (null == shop) {  \n            //将空值写入缓存  \n            stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY + id, \"\", RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES);  \n            return null;        }  \n        //数据存在则写入redis  \n        stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(shop),  \n                RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);  \n    } catch (InterruptedException e) {  \n        e.printStackTrace();  \n    } finally {  \n        //1.5 释放互斥锁  \n        unLockKey(lockKey);  \n    }  \n    return shop;  \n  \n}\n```\n\n- 使用apifox进行高并发测试\n\n\n# 基于逻辑过期解决缓存击穿\n\n- 需要提前添加要设置的热点数据\n\n提前添加的热点数据：\n```java\n@SpringBootTest  \nclass HmDianPingApplicationTests {  \n    @Resource  \n   private ShopServiceImpl shopService;  \n    @Test  \n    public void testShop() throws InterruptedException {  \n        shopService.testSaveShop(1L,10L);  \n    }  \n}\n```\n\n```java\n//创建线程池  \nprivate static final ExecutorService CACHE_REBUILD_EXECUTOR_SERVICE = Executors.newFixedThreadPool(10);  \n  \nprivate Shop query_LogicalExpiration(Long id) {  \n    String info = stringRedisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_KEY + id);  \n    //isNotBlank，null,空字符串，转义字符都返回false  \n    if (StrUtil.isBlank(info)) {  \n        //不存在缓存，直接返回空  \n        return null;  \n    }  \n    //存在，反序列化为对象，判断是否过期  \n    //将redisData对象中的data取出并不能直接转为Shop对象，  \n    //因为再data的属性为Object，需要先转换为JsonObject再转换为Shop对象  \n    RedisData redisData = JSONUtil.toBean(info, RedisData.class);  \n    JSONObject jsonObject = (JSONObject) redisData.getData();  \n    Shop shop = JSONUtil.toBean(jsonObject, Shop.class);  \n    LocalDateTime expireTime = redisData.getExpireTime();  \n  \n    if (expireTime.isAfter(LocalDateTime.now())) {  \n        //未过期，直接返回对象  \n        return shop;  \n    }  \n    //  过期进行缓存重建  \n    //缓存重建,1.获取互斥锁  \n    String lockKey = RedisConstants.LOCK_SHOP_KEY + id;  \n    Boolean isLock = getLockKey(lockKey);  \n    //2.判断是否获取锁成功  \n    if (isLock) {  \n        //3.成功：开启独立线程，实现缓存重建  \n        CACHE_REBUILD_EXECUTOR_SERVICE.submit(() -> {  \n            //重建缓存  \n            try {  \n                this.testSaveShop(id, 20L);  \n            } catch (Exception e) {  \n               throw new RuntimeException(e);  \n            } finally {  \n                //释放锁  \n                unLockKey(lockKey);  \n            }  \n        });  \n    }  \n    //获取锁成功后再次检查缓存是否存在  \n    info = stringRedisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_KEY + id);  \n    if (StrUtil.isNotBlank(info)) {  \n        return JSONUtil.toBean(info, Shop.class);  \n    }  \n    if (info != null) {  \n        return null;  \n    }  \n    //返回过期商铺信息  \n    return shop;  \n}  \n  \n  \npublic void testSaveShop(Long id, Long expireSeconds) throws InterruptedException {  \n    //查询店铺数据  \n    Shop shop = getById(id);  \n    //模拟延迟  \n    Thread.sleep(200);  \n    //封装逻辑过期时间  \n    RedisData redisData = new RedisData();  \n    redisData.setData(shop);  \n    redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));  \n    //写入redis  \n    stringRedisTemplate.opsForValue().  \n            set(RedisConstants.CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(redisData));  \n}\n```\n\n进行测试\n\n# 缓存工具封装\n\n- 工具类\n\n```java\npackage com.hmdp.utils;  \n  \nimport cn.hutool.core.util.BooleanUtil;  \nimport cn.hutool.core.util.StrUtil;  \nimport cn.hutool.json.JSONObject;  \nimport cn.hutool.json.JSONUtil;  \nimport com.hmdp.entity.Shop;  \nimport org.springframework.data.redis.core.StringRedisTemplate;  \nimport org.springframework.stereotype.Component;  \n  \nimport java.time.LocalDateTime;  \nimport java.util.concurrent.ExecutorService;  \nimport java.util.concurrent.Executors;  \nimport java.util.concurrent.TimeUnit;  \nimport java.util.function.Function;  \n  \n@Component  \npublic class CacheClientUtil {  \n    //创建线程池  \n    private static final ExecutorService CACHE_REBUILD_EXECUTOR_SERVICE = Executors.newFixedThreadPool(10);  \n  \n    //这里使用的是构造函数注入StringRedisTemplate  \n    private final StringRedisTemplate stringRedisTemplate;  \n  \n    public CacheClientUtil(StringRedisTemplate stringRedisTemplate) {  \n        this.stringRedisTemplate = stringRedisTemplate;  \n    }  \n  \n    public void set(String key, Object value, Long time, TimeUnit timeUnit) {  \n        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, timeUnit);  \n    }  \n  \n    /**  \n     * 保存并设置逻辑过期时间  \n     * @param key  \n     * @param value  \n     * @param time  \n     * @param timeUnit  \n     */  \n    public void setLogicalExpire(String key,Object value,Long time,TimeUnit timeUnit){  \n              RedisData redisData = new RedisData();  \n              redisData.setData(value);  \n              redisData.setExpireTime(LocalDateTime.now().plusSeconds(timeUnit.toSeconds(time)));  \n  \n              stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));  \n    }  \n  \n    public <R,ID> R queryWithPassThrough(String keyPrefix, ID id, Class<R> type,  \n                                         Function<ID,R> function,Long time,TimeUnit timeUnit){  \n        String key = keyPrefix+id;  \n        String info = stringRedisTemplate.opsForValue().get(key);  \n        //isNotBlank，null,空字符串，转义字符都返回false  \n        if (StrUtil.isNotBlank(info)) {  \n            return JSONUtil.toBean(info, type);  \n        }  \n        //判断是否未空值  \n        if (info != null) {  \n            return null;  \n        }  \n        //由于不知道要查询的是那个类型的数据，  \n        //所以由调用者传入对应的查询函数 Function<ID,R> 需要的函数参数为ID,返回值为R  \n        R r = function.apply(id);  \n        if (null == r) {  \n            //将空值写入缓存  \n            stringRedisTemplate.opsForValue().set( key, \"\",  time, timeUnit);  \n            return null;        }  \n        //数据存在则写入redis  \n         this.set(key,r,time,timeUnit);  \n        return r;  \n  \n    }  \n    public  <R,ID> R query_LogicalExpiration(String keyPrefix,ID id,Class<R> type,  \n                                             Function<ID,R> function,Long time,TimeUnit timeUnit) {  \n        String key = keyPrefix+id;  \n        String info = stringRedisTemplate.opsForValue().get(key);  \n        if (StrUtil.isBlank(info)) {  \n            return null;  \n        }  \n        //存在，反序列化为对象，判断是否过期  \n        RedisData redisData = JSONUtil.toBean(info, RedisData.class);  \n        JSONObject jsonObject = (JSONObject) redisData.getData();  \n        R r = JSONUtil.toBean(jsonObject,type);  \n        LocalDateTime expireTime = redisData.getExpireTime();  \n  \n        if (expireTime.isAfter(LocalDateTime.now())) {  \n            //未过期，直接返回对象  \n            return r;  \n        }  \n        //  过期进行缓存重建  \n        //缓存重建,1.获取互斥锁  \n        String lockKey = RedisConstants.LOCK_SHOP_KEY + id;  \n        Boolean isLock = getLockKey(lockKey);  \n        //2.判断是否获取锁成功  \n        if (isLock) {  \n            //3.成功：开启独立线程，实现缓存重建  \n            CACHE_REBUILD_EXECUTOR_SERVICE.submit(() -> {  \n                //重建缓存  \n                try {  \n                   //查询数据库  \n                    R apply = function.apply(id);  \n                    //写入redis  \n                  this.setLogicalExpire(key,apply,time,timeUnit);  \n                } catch (Exception e) {  \n                    throw new RuntimeException(e);  \n                } finally {  \n                    //释放锁  \n                    unLockKey(lockKey);  \n                }  \n            });  \n        }  \n        //获取锁成功后再次检查缓存是否存在  \n        info = stringRedisTemplate.opsForValue().get(key);  \n        if (StrUtil.isNotBlank(info)) {  \n            return JSONUtil.toBean(info, type);  \n        }  \n        if (info != null) {  \n            return null;  \n        }  \n        //返回过期商铺信息  \n        return r;  \n    }  \n    /**  \n     * 生成锁  \n     *  \n     * @param key  \n     * @return  \n     */  \n    private Boolean getLockKey(String key) {  \n        Boolean aBoolean = stringRedisTemplate.opsForValue().setIfAbsent(key, \"1\",  \n                10, TimeUnit.SECONDS);  \n        return BooleanUtil.isTrue(aBoolean);  \n    }  \n  \n    /**  \n     * 删除锁  \n     *  \n     * @param key  \n     */  \n    private void unLockKey(String key) {  \n        stringRedisTemplate.delete(key);  \n    }  \n  \n  \n}\n```\n\n- 工具类方法的调用\n\n```java\n    @Resource  \n    private CacheClientUtil cacheClientUtil;  \n    @Override  \n    public Result query(Long id) {  \n        //使用工具类解决缓存穿透  \n//     Shop shop =  cacheClientUtil.queryWithPassThrough(RedisConstants.CACHE_SHOP_KEY,id,  \n//             Shop.class,id2->{  \n//              return getById(id2);  \n//             },RedisConstants.CACHE_SHOP_TTL,TimeUnit.MINUTES);  \n        //使用工具类解决缓存击穿,  \n        // 注意：需要提前注入缓存数据  \n        Shop shop = cacheClientUtil.query_LogicalExpiration(RedisConstants.CACHE_SHOP_KEY,id,  \n                Shop.class,id2->{  \n                    return getById(id2);  \n                },20L,TimeUnit.SECONDS);  \n        if (null == shop) {  \n            return Result.fail(\"该店铺信息不存在\");  \n        }  \n        return Result.ok(shop);  \n    }\n```\n\n\n# 优惠卷秒杀\n\n业务场景：\n每个店铺可以发布优惠卷，用户可以去抢购优惠卷\n\n## 全局唯一ID\n\n- 用户在抢购优惠卷时相关的订单信息将保存到tb_voucher_order这张表中，这张表的id没有使用自增\n- 原因：\n1. id的规律性太明显\n2. 受表单数量的限制\n\n解决方法：全局id生成器(是一种在分布式系统人下用来生成全局唯一Id的工具)\n\n全局id生成器需要满足的特性：\n1. 唯一性\n2. 高可用\n3. 高性能\n4. 递增性\n5. 安全性\n\n在使用redis作为全局id生成器时，为了增加id的安全性，不直接使用redis自增的数值，而是拼接一些其他的信息\n\n**ID的组成部分：**\n1. 符号位：1bit 永远为0\n2. 时间戳: 31bit，以秒为单位，可以使用69年\n3. 序列号：32bit，秒内的计数器，支持每秒产生2^32个不同的ID\n\n![image-20221016192658797](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221016.19-27-00.png)\n\n\n\n```java\n@Component  \npublic class RedisGlobalIdGenerator {  \n  \n    //起始时间\n    private static final long START_TIME = 1665878400L;  \n    //序列号的位数  \n    private static final int COUNT_BITS = 32;  \n    private final StringRedisTemplate stringRedisTemplate;  \n  \n    public RedisGlobalIdGenerator(StringRedisTemplate stringRedisTemplate) {  \n        this.stringRedisTemplate = stringRedisTemplate;  \n    }  \n  \n    public long nextId(String keyPrefix) {  \n        //生成时间戳  \n        LocalDateTime localDateTime = LocalDateTime.now();  \n        long NOW_TIME = localDateTime.toEpochSecond(ZoneOffset.UTC);  \n        long timeStamp = NOW_TIME - START_TIME;  \n        //生成序列号  \n        //1.获取当前的日期  \n        String yyyyMMdd = localDateTime.format(DateTimeFormatter.ofPattern(\"yyyy:MM:dd\"));  \n        //自增长  \n        long increment = stringRedisTemplate.opsForValue().increment(\"icr:\" + keyPrefix + \":\" + yyyyMMdd);  \n        //拼接并返回  \n        return timeStamp<< COUNT_BITS | increment;  \n    }  \n//生成起始时间  \n//    public static void main(String[] args) {  \n//        LocalDateTime time = LocalDateTime.of(2022,10,16,0,0);  \n//        long l = time.toEpochSecond(ZoneOffset.UTC);  \n//        System.out.println(\"L==\"+l);  \n//    }  \n}\n```\n\n- 测试\n```java\n    @Resource  \n    private RedisGlobalIdGenerator idGenerator;  \n    ExecutorService executorService = Executors.newFixedThreadPool(70);  \n    @Test  \n    public void test3(){  \n  \n//       Runnable task = ()->{  \n//           log.debug(\"开始任务\");  \n//           for (int i = 0; i < 100; i++) {  \n//               long id = idGenerator.nextId(\"test\");  \n//               System.out.println(\"id==\"+id);  \n//           }  \n//       } ;  \n//        for (int i = 0; i < 70; i++) {  \n//     //       log.debug(\"进入任务\");  \n//          executorService.submit(task);  \n//        }  \n        long test = idGenerator.nextId(\"test\");  \n        System.out.println(test);  \n    }\n```\n\n\n## 实现优惠卷秒杀\n\n- **下单时需要注意的地方：**\n1. 秒杀是否开始，或已经结束\n2. 库存是否足够\n\n```java\n@Service  \npublic class VoucherOrderServiceImpl extends ServiceImpl<VoucherOrderMapper, VoucherOrder> implements IVoucherOrderService {  \n  \n    @Resource  \n    private ISeckillVoucherService seckillVoucherService;  \n  \n    @Resource  \n    private RedisGlobalIdGenerator redisGlobalIdGenerator;  \n  \n    @Override  \n    @Transactional    public Result voucherOrder(Long voucherId) {  \n        //1. 查询优惠卷  \n        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);  \n        //2. 判断秒杀是否开始  \n        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {  \n            //未开始  \n            return Result.fail(\"秒杀未开始\");  \n        }  \n        //3. 判断秒杀是否结束  \n        if (voucher.getEndTime().isBefore(LocalDateTime.now())) {  \n            return Result.fail(\"秒杀已经结束\");  \n        }  \n        //4. 判断库存是否充足  \n        if (voucher.getStock() < 1) {  \n            return Result.fail(\"优惠卷已被强光\");  \n        }  \n        //5. 扣除库存  \n        boolean is_success = seckillVoucherService.update().setSql(\"stock = stock - 1\")  \n                .eq(\"voucher_id\", voucherId).update();  \n        if (!is_success) {  \n            return Result.fail(\"库存不足\");  \n        }  \n        //6. 创建订单  \n        VoucherOrder voucherOrder = new VoucherOrder();  \n        //6.1订单id  \n        long order = redisGlobalIdGenerator.nextId(\"order\");  \n        voucherOrder.setId(order);  \n        //6.2用户id  \n        Long id = UserHolder.getUser().getId();  \n        voucherOrder.setUserId(id);\n```\n\n\n## 添加乐观锁解决并发安全问题\n\n解决并发安全问题的方案：\n1. **悲观锁：** 添加同步锁，让线程串行执行\n- 优点：简单粗暴\n- 缺点：性能一般\n\n2. **乐观锁：** 不加锁，在更新时判断是否有其它线程在修改\n- 优点：性能好\n- 缺点：存在成功率低的问题\n\n- 乐观锁关键是判断之前查询到的数据是否又被修改\n- 这里使用CAS法\n这里在扣除库存这里添加乐观锁\n```java\n       //5. 扣除库存  \n        boolean is_success = seckillVoucherService.update().setSql(\"stock = stock - 1\")  \n                .eq(\"voucher_id\", voucherId)  \n                //乐观锁,这里通过查询到的优惠卷库存进行比较判断是否数据被修改  \n                //但是这样会导致明明库存可以进行扣除却因为数据被修改而不能进行扣除  \n//                .eq(\"stock\",voucher.getStock()).update();  \n                //对于这里的业务可以当库存大于0就可以进行修改  \n                .gt(\"stock\",0).update();  \n        if (!is_success) {  \n            return Result.fail(\"库存不足\");  \n        }\n```\n\n## 一人一单\n- 更改秒杀业务，要求同一个优惠卷，一个用户只能下一单\n- 在用户下单时，先根据优惠卷id和用户id查询订单，判断是否已存在订单，若存在则阻止下单。\n\n```java\n@Override  \npublic Result voucherOrder(Long voucherId) {  \n    //1. 查询优惠卷  \n    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);  \n    //2. 判断秒杀是否开始  \n    if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {  \n        //未开始  \n        return Result.fail(\"秒杀未开始\");  \n    }  \n    //3. 判断秒杀是否结束  \n    if (voucher.getEndTime().isBefore(LocalDateTime.now())) {  \n        return Result.fail(\"秒杀已经结束\");  \n    }  \n    //4. 判断库存是否充足  \n    if (voucher.getStock() < 1) {  \n        return Result.fail(\"优惠卷已被强光\");  \n    }  \n    //给方法上锁  \n    //一人一单  \n    Long id = UserHolder.getUser().getId();  \n    //给用户id上锁  \n    //但是即使相同的id转为字符串时可能还是会导致锁的对象不一致  \n    //因此使用.intern()返回字符串对象的规范表示，来保证id转为String对象的唯一性  \n    synchronized (id.toString().intern()) {  \n        //拿到当前对象的代理对象,使用当前代理对象调用的方法才不会使事务失效  \n         IVoucherOrderService proxy =(IVoucherOrderService) AopContext.currentProxy();  \n        //返回订单id  \n        return proxy.createOrderOrder(voucherId, id);  \n    }  \n}\n```\n\n```java\n @Transactional  \n    public Result createOrderOrder(Long voucherId, Long id) {  \n        //根据优惠卷id和用户id查询是否已存在订单  \n        int count = query().eq(\"user_id\", id).eq(\"voucher_id\", voucherId).count();  \n        if (count > 0) {  \n            return Result.fail(\"一个用户只能购买一次\");  \n        }  \n        //5. 扣除库存  \n        boolean is_success = seckillVoucherService.update().setSql(\"stock = stock - 1\")  \n                .eq(\"voucher_id\", voucherId)  \n                //乐观锁,这里通过查询到的优惠卷库存进行比较判断是否数据被修改  \n                //但是这样会导致明明库存可以进行扣除却因为数据被修改而不能进行扣除  \n//                .eq(\"stock\",voucher.getStock()).update();  \n                //对于这里的业务可以当库存大于0就可以进行修改  \n                .gt(\"stock\", 0).update();  \n        if (!is_success) {  \n            return Result.fail(\"库存不足\");  \n        }  \n        //6. 创建订单  \n        VoucherOrder voucherOrder = new VoucherOrder();  \n        //6.1订单id  \n        long order = redisGlobalIdGenerator.nextId(\"order\");  \n        voucherOrder.setId(order);  \n        //6.2用户id  \n        voucherOrder.setUserId(id);  \n        //6.3代金卷id  \n        voucherOrder.setVoucherId(voucherId);  \n        save(voucherOrder);  \n        return Result.ok(order);  \n    }\n```\n\n- 使用代理对象需要注入相关依赖\n```xml\n<dependency>  \n    <groupId>org.aspectj</groupId>  \n    <artifactId>aspectjweaver</artifactId>  \n</dependency>\n```\n\n- 在启动类上添加注解开启\n\n```java\n//暴露代理对象  \n@EnableAspectJAutoProxy(exposeProxy = true)  \n@MapperScan(\"com.hmdp.mapper\")  \n@SpringBootApplication  \npublic class HmDianPingApplication {  \n  \n    public static void main(String[] args) {  \n        SpringApplication.run(HmDianPingApplication.class, args);  \n    }  \n  \n}\n```\n\n\n- 单个jvm锁的实现\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221018.14-15-59.png)\n\n# 分布式锁\n- **满足分布式系统或集群模式下多进程可见并且互斥的锁**\n\n\n- 当出现集群多个jvm的锁都是不一样的所以会造成线程安全问题\n\n\n- 分布式锁通过锁监视器，使所有jvm使用锁都是同一个\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221018.14-14-21.png)\n\n\n## 分布式锁的实现\n\n- 分布式锁的核心使实现多进程之间互斥，而满足这一点的方式常见的有三种\n\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221018.14-39-24.png)\n\n- **基于redis的分布式锁**\n\n### 获取锁\n - 利用setnx命令来实现**互斥**(确保只能有一个线程获取锁)\n -  非阻塞：只尝试一次，成功返回true 失败返回false\n\n```bash\nSET lockKey value NX EX 10\n```\n1. NX代表互斥\n2. EX设置超时时间(单位为秒)\n### 释放锁\n\n- 手动释放（删除对应的key）\n- 超时释放：获取锁时添加一个超时时间\n\n**流程：**\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221018.15-02-31.png)\n\n## 基于redis实现分布式锁初级版本\n\n- 定义一个接口==ILock==\n```java\npublic interface ILock {  \n    /**  \n     * 尝试获取锁  \n     * @param timeOutSec 锁持有的超时时间，过期后自动释放  \n     * @return true代表获取锁成功false代表获取失败  \n     */  \n    Boolean tryLock(long timeOutSec);  \n  \n    /**  \n     * 释放锁  \n     */  \n     void unLock();  \n}\n```\n- 再定义一个类实现==ILock==接口\n\n**测试：**\n\n- idea服务启动两份端口号分别为8081和8082\n在运行/调试配置使用“CTRL”+“D”即可复制一个一模一样的运行配置，在vm进行配置==-Dserver.port=8082==覆盖原来的端口号\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221018.16-17-32.png)\n\n- 在nginx文件夹的conf文件内修改nginx.conf文件，配置反向代理和负载均衡\n将第二个注释关闭\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221018.16-06-30.png)\n\n## 解决分布式锁误删\n- 当线程1去获取锁执行业务时，**阻塞的时间超过了锁设置的超时时间**，导致锁被超时释放但是线程1还是在进行业务，\n- 这时线程2由于锁被超时释放，线程则在线程1还未完成业务的情况下获取获取到了锁，而线程1完成业务时，线程2还在执行业务但是，线程1完成业务触发释放锁，将线程2的锁给释放了。\n- 而线程3又可以在线程2还未完成业务的情况下继续获取到锁，此时出现了两个线程同时执行业务的错误\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221018.18-13-02.png)\n\n**解决方法：**\n- 在释放锁时判断锁的标识是否一致\n\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221018.18-18-08.png)\n\n\n- **新的流程**\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221018.18-05-50.png)\n\n\n## Lua脚本解决命令原子性问题\n\n- redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性\n- redis提供的调用函数去执行redis命令：\n```bash\nredis.call('命令名称','key'，'其他参数'...)\n```\n**例：** 执行set hello world\n脚本是\n```bash\nredis.call('set','hello','world')\n```\n\n- 脚本完成后需要使用redis命令==EVAL==调用脚本\n**例如执行redis.call('set','hello','world')脚本：**\n```bash\nEVAL \"return redis.call('set','hello','world')\" 0\n```\n\n<u>这里的0代表参数数量</u>\n\n如果脚本中的key. value不想写死，可以作为参数传递。key类型参数会放入KEYS数组,其它参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数: \n\n- **lua语言数组的开始是从1开始**\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221019.13-51-55.png)\n\n\n### 编写的Lua脚本：\n```lua\n-- 锁的key\nlocal key = KEYS[1]\n-- 当前线程的标识\nlocal threadId = ARGV[1]\n-- 获取锁中的线程标识\nlocal id = redis.call('get',key)\n-- 比较线程标识是否与锁标识一致\nif(threadId==id)then\n    -- 释放锁\n    return redis.call('del',key)\nend\n\nreturn 0\n```\n\n\n### 基于Lua脚本实现分布式锁的释放逻辑\n\n- RedisTemplate调用lua脚本的api：\n```java\npublic <T> T execute(RedisScript<T> script, List<K> keys, Object... args) {  \n    return this.scriptExecutor.execute(script, keys, args);  \n}\n```\n\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221019.14-12-45.png)\n\n\n- 为了以后便于调整脚本内容在项目resourse文件夹下创建unlock.lua文件写入脚本\n\n```java\npublic class SimpleRedisLock implements ILock {  \n  \n    private StringRedisTemplate stringRedisTemplate;  \n    private String ServiceType;  \n  \n    private static final String KEY_PREFIX = \"lock:\";  \n    //使用uuid生成标识符前缀  \n    private static final String ID_PREFIX = UUID.randomUUID().toString(true) + \":\";  \n  \n    public SimpleRedisLock(StringRedisTemplate stringRedisTemplate, String serviceType) {  \n        this.stringRedisTemplate = stringRedisTemplate;  \n        ServiceType = serviceType;  \n    }  \n  \n    //提前读取lua脚本内容  \n    private static final DefaultRedisScript<Long> UNLOCK_SCRIPT;  \n  \n    static {  \n        //初始化UNLOCK_SCRIPT脚本  \n        UNLOCK_SCRIPT = new DefaultRedisScript<>();  \n        //setLocation()是DefaultRedisScript提供的读取文件的方法，  \n        // ClassPathResource()是默认从项目的resource问价下读取  \n        UNLOCK_SCRIPT.setLocation(new ClassPathResource(\"unlock.lua\"));  \n        UNLOCK_SCRIPT.setResultType(Long.class);  \n    }  \n  \n    @Override  \n    public Boolean tryLock(long timeOutSec) {  \n        //获取当前线程表示  \n        String threadId = ID_PREFIX + Thread.currentThread().getId();  \n        //获取锁  \n        Boolean is_success = stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + ServiceType, threadId,  \n                timeOutSec, TimeUnit.SECONDS);  \n        //不直接返回布尔值，避免空指针  \n        return Boolean.TRUE.equals(is_success);  \n    }  \n  \n    //    @Override  \n//    public void unLock() {  \n//        //获取线程标识  \n//        String threadId = ID_PREFIX + Thread.currentThread().getId();  \n//        //获取redis锁中的标识  \n//        String s = stringRedisTemplate.opsForValue().get(ID_PREFIX + ServiceType);  \n//        if (threadId.equals(s)) {  \n//            stringRedisTemplate.delete(KEY_PREFIX + ServiceType);  \n//        }  \n//    }  \n    @Override  \n    public void unLock() {  \n        //调用lua脚本  \n        stringRedisTemplate.execute(UNLOCK_SCRIPT,  \n                Collections.singletonList(KEY_PREFIX + ServiceType),  \n                ID_PREFIX + Thread.currentThread().getId());  \n    }  \n}\n```\n\n## 总结\n\n**基于redis的分布式锁的实现思路：**\n- 利用set nx ex 获取锁，并设置过期时间，保存线程标识\n- 释放锁时先判断标识是否与自己的一致，一致才删除\n\n**特性：**\n1. 利用set nx满足互斥性\n2. 利用set ex保证故障时锁依然能释放，避免死锁，提高安全性\n3. 利用redis集群保证高可用和高并发特性\n\n\n# 基于redis分布式锁的优化\n\n- 基于setnx实现的分布式锁存在下面的问题：\n1. **不可重入：** 同一个线程无法多次获取同一把锁\n2. **不可重试：** 获取锁只能尝试一次，没有重试机制\n3. **超时释放：** 锁超时释放虽然可以避免死锁，但如果是业务执行耗时较长，也会导致锁释放存在安全隐患\n4. **主从一致性：** 如果redis提供了主从集群，主从同步存在延迟可能会出现问题\n\n## Redisson\n\n- redisson是一个在redis的基础上实现的Java驻内存数据网格(In-Memory Data Grid)，它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现\nGitHub：[redisson/redisson: Redisson - Redis Java client with features of In-Memory Data Grid.(github.com)](https://github.com/redisson/redisson)\n\n\n## Redisson入门\n\n1. **引入依赖**\n```xml\n<!-- https://mvnrepository.com/artifact/org.redisson/redisson -->\n<dependency>\n    <groupId>org.redisson</groupId>\n    <artifactId>redisson</artifactId>\n    <version>3.16.7</version>\n</dependency>\n\n```\n\n2. **创建配置类配置Redisson客户端**\n\n```java\n  \n@Configuration  \npublic class RedissonConfig {  \n    @Bean  \n    RedissonClient redissonClient(){  \n        //配置类  \n        Config config = new Config();  \n        //添加redis地址，这里添加了单点地址，  \n        //也可以使用config.useClusterServers()添加集群地址,有密码的话再.setPassword()设置密码  \n        config.useSingleServer().setAddress(\"redis://192.168.157.129:6379\");  \n        //创建客户端  \n        return Redisson.create(config);  \n    }  \n}\n```\n\n\n\n\n3. **对原来的代码进行改造：**\n\n\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221019.16-10-32.png)\n\n\n- 这里只是将原来的strRedisTemplate锁改为了Redisson提供的锁，业务逻辑没有发送改变\n```java\n   //使用redis分布锁给用户id上锁  \n//   SimpleRedisLock simpleRedisLock = new SimpleRedisLock(stringRedisTemplate, \"order:\" + id);  \n   //使用redisson获取锁  \n   RLock lock = redissonClient.getLock(\"order:\" + id);  \n   //获取锁  注意设置的超时时间与具体的业务有关  \n   Boolean is_lock = lock.tryLock();  \n   if (!is_lock) {  \n       //获取锁失败，根据具体业务返回错误信息或重试  \n       return Result.fail(\"重复下单失败\");  \n   }  \n   try {  \n       IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();  \n       return proxy.createOrderOrder(voucherId, id);  \n   } finally {  \n       //当业务出现异常时，保证锁一定被释放  \n     lock.unlock();  \n   }\n```\n\n## Redisson可重入锁原理\n\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221020.08-42-45.png)\n\n## Redisson分布式锁原理\n\n\n- **可重入：** 利用hash结构记录线程id和可重入次数\n- **可重试：** 利用信号量和PubSub功能实现等待，唤醒，获取锁失败的重试机制\n- **超时续约：** 利用watchDog,每隔一段时间，重置超时时间\n\n\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221020.09-08-17.png)\n\n\n## Redisson分布式锁主从一致性问题\n\n\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221020.09-42-00.png)\n# 基于阻塞队列的异步秒杀\n\n\n\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221020.10-20-36.png)\n\n- 新增秒杀优惠卷的同时将优惠卷信息保存到redis中\n在VoucherServiceImpl的addSeckillVoucher方法进行修改\n\n```java\n    @Override  \n    @Transactional    public void addSeckillVoucher(Voucher voucher) {  \n        // 保存优惠券  \n        save(voucher);  \n        // 保存秒杀信息  \n        SeckillVoucher seckillVoucher = new SeckillVoucher();  \n        seckillVoucher.setVoucherId(voucher.getId());  \n        seckillVoucher.setStock(voucher.getStock());  \n        seckillVoucher.setBeginTime(voucher.getBeginTime());  \n        seckillVoucher.setEndTime(voucher.getEndTime());  \n        seckillVoucherService.save(seckillVoucher);  \n        //保存优惠卷库存信息到redis  \n        stringRedisTemplate.opsForValue().  \n                set(RedisConstants.SECKILL_STOCK_KEY+voucher.getId(),  \n                        voucher.getStock().toString());  \n    }  \n}\n```\n- 基于lua脚本，判断秒杀库存，一人一单，判断用户是否抢购成功\nlua脚本：\n\n```lua \n-- 优惠卷id  \nlocal voucherId = ARGV[1]  \n-- 用户id  \nlocal userId = ARGV[2]  \n-- 库存key  \nlocal stockKey = 'seckill:stock:' .. voucherId  \n-- 订单key  \nlocal orderKey = 'seckill:order:' .. voucherId  \n-- 判断库存是否充足  \nif(tonumber(redis.call(\"get\",stockKey)) <= 0) then  \n    -- 库存不足，返回1  \n    return 1  \nend  \n-- 判断用户是否下单  \nif (redis.call('SISMEMBER',orderKey,userId)==1) then  \n    -- 存在重复下单返回2  \n    return 2  \nend  \n-- 扣除库存  \nredis.call('incrby',stockKey,-1)  \n-- 下单  \nredis.call('sadd',orderKey,userId)  \nreturn 0```\n\n\n- 抢购成功后，将优惠卷id和用户id封装后存入阻塞队列\n\n- 开启线程任务，不断从阻塞队列中获取信息，实现异步下单\n```java\n@Service  \n@Slf4j  \npublic class VoucherOrderServiceImpl extends ServiceImpl<VoucherOrderMapper, VoucherOrder> implements IVoucherOrderService {  \n  \n    @Resource  \n    private ISeckillVoucherService seckillVoucherService;  \n  \n    @Resource  \n    private RedisGlobalIdGenerator redisGlobalIdGenerator;  \n  \n    @Resource  \n    private StringRedisTemplate stringRedisTemplate;  \n  \n    @Resource  \n    private RedissonClient redissonClient;  \n    //提前读取lua脚本内容  \n    private static final DefaultRedisScript<Long> JUDGE_ORDER_SCRIPT;  \n  \n    static {  \n        //初始化UNLOCK_SCRIPT脚本  \n        JUDGE_ORDER_SCRIPT = new DefaultRedisScript<>();  \n        //setLocation()是DefaultRedisScript提供的读取文件的方法，  \n        // ClassPathResource()是默认从项目的resource问价下读取  \n        JUDGE_ORDER_SCRIPT.setLocation(new ClassPathResource(\"JudgeTheOrder.lua\"));  \n        JUDGE_ORDER_SCRIPT.setResultType(Long.class);  \n    }  \n  \n    //创建阻塞队列  \n    private BlockingQueue<VoucherOrder> blockingQueue = new ArrayBlockingQueue<>(1024 * 1024);  \n    //创建异步下单的线程  \n    private static final ExecutorService executorService = Executors.newSingleThreadExecutor();  \n    //PostConstruct是spring提供的注解当这个类一但完成初始化时就执行注解下的方法  \n    @PostConstruct  \n    private void init(){  \n        executorService.submit(new VoucherOrderTask());  \n    }  \n    //下单的任务  \n   private class  VoucherOrderTask implements Runnable{  \n  \n        @Override  \n        public void run() {  \n            //不断从队列中获取订单信息，创建订单  \n           while (true){  \n               try {  \n                   VoucherOrder voucherOrder = blockingQueue.take();  \n                   //创建订单  \n                   handleVoucherOrder(voucherOrder);  \n               } catch (Exception e) {  \n                   log.error(\"订单处理异常\",e);  \n               }  \n           }  \n        }  \n    }  \n  \n    private void handleVoucherOrder(VoucherOrder voucherOrder) {  \n        Long id = voucherOrder.getUserId();  \n        //使用redisson获取锁  \n        RLock lock = redissonClient.getLock(\"lock:order:\" + id);  \n        //获取锁  注意设置的超时时间与具体的业务有关  \n        Boolean is_lock = lock.tryLock();  \n        if (!is_lock) {  \n            //获取锁失败，根据具体业务返回错误信息或重试  \n             log.error(\"重复下单失败\");  \n             return;        }  \n        try {  \n           proxy.createOrderOrder(voucherOrder);  \n        } finally {  \n            //当业务出现异常时，保证锁一定被释放  \n          lock.unlock();  \n        }  \n    }  \n  \n    private  IVoucherOrderService proxy;  \n    @Override  \n    public Result voucherOrder(Long voucherId) {  \n        //获取用户id  \n        Long id = UserHolder.getUser().getId();  \n        //执行lua脚本  \n        Long result = stringRedisTemplate.execute(JUDGE_ORDER_SCRIPT,  \n                Collections.emptyList(), voucherId.toString(), id.toString());  \n        //判断结果，为0可以去下单  \n        int i = result.intValue();  \n        if (0!=i){  \n            return Result.fail(1 == i ?\"库存不足\" : \"不能重复下单\");  \n        }  \n        //可以下单，  \n        long orderId = redisGlobalIdGenerator.nextId(\"order\");  \n        //封装  \n        VoucherOrder voucherOrder = new VoucherOrder();  \n        long order = redisGlobalIdGenerator.nextId(\"order\");  \n        voucherOrder.setId(order);  \n        voucherOrder.setUserId(id);  \n        voucherOrder.setVoucherId(voucherId);  \n        //将下单信息放入阻塞队列  \n        blockingQueue.add(voucherOrder);  \n        //获取代理对象  \n        proxy = (IVoucherOrderService) AopContext.currentProxy();  \n        return Result.ok(orderId);  \n    }  \n  \n  \n\n  \n    @Transactional  \n    public  void createOrderOrder(VoucherOrder voucherOrder) {  \n        //根据优惠卷id和用户id查询是否已存在订单  \n        Long userId = voucherOrder.getUserId();  \n        int count = query().eq(\"user_id\",userId).eq(\"voucher_id\",voucherOrder.getVoucherId()).count();  \n        if (count > 0) {  \n            log.error(\"无法重复下单\");  \n            return ;        }  \n        //5. 扣除库存  \n        boolean is_success = seckillVoucherService.update().setSql(\"stock = stock - 1\")  \n                .eq(\"voucher_id\",voucherOrder.getVoucherId())  \n                //乐观锁,这里通过查询到的优惠卷库存进行比较判断是否数据被修改  \n                //但是这样会导致明明库存可以进行扣除却因为数据被修改而不能进行扣除  \n//                .eq(\"stock\",voucher.getStock()).update();  \n                //对于这里的业务可以当库存大于0就可以进行修改  \n                .gt(\"stock\", 0).update();  \n        if (!is_success) {  \n            log.error(\"库存不足\");  \n            return ;        }  \n        //6. 创建订单  \n         save(voucherOrder);  \n    }  \n}\n```\n\n\n# Redis实现消息队列实现异步秒杀\n\n## 基于List结构模拟消息队列\n\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221020.15-56-22.png)\n优点：\n1. 利用redis存储，不受限于JVM内存上限\n2. 基于redis的持久化机制，数据安全性有保证\n3. 可以满足消息有序性\n\n缺点：\n1. 无法避免消息丢失\n2. 只支持单消费者\n\n## 基于PubSub的消息队列\n\n>pubSub是redis2.0引入的消息传递模型，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后所有订阅者都能收到相关消息。\n\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221020.16-10-45.png)\n优点：\n1. 采用发布订阅模型，支持多生产，多消费\n缺点：\n1. 不支持数据持久化\n2. 无法避免消息丢失\n3. 消息堆积有上限，超出时数据丢失\n\n\n## 基于Stream的消息队列\n\n> Stream是redis5.0引入的一种新的数据类型，可以实现一个功能非常完善的消息队列\n\n**发送消息的命令==XADD==:**\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221020.16-18-13.png)\n\n例：\n- 创建名为users的队列，并向其中发送一个消息，内容是{name=bob,age=21}，并且使用redis自动生成id\n\n```bash\nxadd users * name bob age 21\n```\n\n**读取消息方式之一XREAD：**\n\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221020.16-23-13.png)\n\n例：\n读取user队列中的第一个消息\n```bash\nxread count 1 streams users 0\n```\n\nXREAD阻塞方式读取最新的消息：\n```bash\nxread count 1 block 1000 streams users $\n```\n\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221020.16-36-51.png)\n\n**特点：**\n- 消息可回溯\n- 一个消息可以被多个消费者读取\n- 可以阻塞读取\n- 有消息漏读的风险\n\n## 基于stream的消息队列-消费者组\n\n\n\n- 消费者组：将多个消费者划分到一个组中，监听同一个队列，特点：\n\n1. **消息分流：** 队列中的消息会分流给组内的不同消费者，而不是重复消费，来加快消息处理的速度\n2. **消息标示：** 消费者组会维护一个标示，记录最后一个被处理的消息，哪怕消费者宕机重启，还会从表示之后读取消息，确保每一个消息都会被消费\n3. **消息确认：** 消费者读取消息后，消息处于pending状态，并存入一个pending-list。当处理完成后需要通过XACK来确认消息，标记消息为已处理，才会从pending-list移除\n\n**创建消费者组:**\n\n```bash\nXGROUP CREATE key groupName ID [MKSTREAM]\n```\n- key:队列名称\n- groupName：消费者组名称\n- ID：起始ID表示，$代表队列中最后一个消息，0代表队列中第一个消息\n- MKSTREAM : 当队列不存在时自动创建队列 \n\n**其他常见命令：**\n\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221020.16-52-00.png)\n\n**从消费者组读取消息：**\n\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221020.16-54-31.png)\n\n**STREANM类型消息队列的XREADGROUP命令特点：**\n- 消息可回溯\n\n- 可以多消费者争抢消息，加快消费速度\n\n- 可以阻塞读取\n\n- 没有消息漏读的风险\n\n- 有消息确认机制，保证消息至少被消费一次\n\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221020.17-06-38.png)\n\n## redis的stream结构作为消息队列，实现异步秒杀下单\n\n1. 在redis客户端，创建一个stream类型的消息队列stream.orders \n```bash\nXGROUP CREATE stream.orders g1 0 MKSTREAM\n```\n\n\n2. 修改之前秒杀下单的lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId,userId,orderId\n\n- **lua脚本：**\n```java\n-- 优惠卷id  \nlocal voucherId = ARGV[1]  \n-- 用户id  \nlocal userId = ARGV[2]  \n-- 订单id  \nlocal orderId = ARGV[3]  \n-- 库存key  \nlocal stockKey = 'seckill:stock:' .. voucherId  \n-- 订单key  \nlocal orderKey = 'seckill:order:' .. voucherId  \n-- 判断库存是否充足  \nif(tonumber(redis.call(\"get\",stockKey)) <= 0) then  \n    -- 库存不足，返回1  \n    return 1  \nend  \n-- 判断用户是否下单  \nif (redis.call('SISMEMBER',orderKey,userId)==1) then  \n    -- 存在重复下单返回2  \n    return 2  \nend  \n-- 扣除库存  \nredis.call('incrby',stockKey,-1)  \n-- 下单  \nredis.call('sadd',orderKey,userId)  \n  \n-- 发送消息到队列中 XADD stream.orders * k1 v1 k2 v2...redis.call('XADD','stream.orders','*','userId',userId,'voucherId',voucherId,'id',orderId)  \nreturn 0\n```\n\n```java\nprivate  IVoucherOrderService proxy;  \n@Override  \npublic Result voucherOrder(Long voucherId) {  \n    //获取用户id  \n    Long id = UserHolder.getUser().getId();  \n    //获取订单id  \n    long orderId = redisGlobalIdGenerator.nextId(\"order\");  \n    //执行lua脚本  \n    Long result = stringRedisTemplate.execute(JUDGE_ORDER_SCRIPT,  \n            Collections.emptyList(),  \n            voucherId.toString(),id.toString(),String.valueOf(orderId));  \n    //判断结果，为0可以去下单  \n    int i = result.intValue();  \n    if (0!=i){  \n        return Result.fail(1 == i ?\"库存不足\" : \"不能重复下单\");  \n    }  \n    //获取代理对象  \n    proxy = (IVoucherOrderService) AopContext.currentProxy();  \n    return Result.ok(orderId);  \n}\n```\n\n3. 项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单\n```java\nString queueName = \"stream.orders\";  \nprivate class VoucherOrderTask implements Runnable {  \n    @Override  \n    public void run() {  \n        while (true) {  \n            try {  \n                //从消息队列中获取订单信息，创建订单  \n                List<MapRecord<String, Object, Object>> mapRecords = stringRedisTemplate.opsForStream().read(  \n                        //从哪一个组中读取  \n                        Consumer.from(\"g1\", \"c1\"),  \n                        //指定读取的数量并设置阻塞时间为2秒  \n                        StreamReadOptions.empty().count(1).block(Duration.ofSeconds(2)),  \n                        StreamOffset.create(queueName, ReadOffset.lastConsumed())  \n                );  \n                //判断消息是否获取成功  \n                if (null == mapRecords || mapRecords.isEmpty()) {  \n                    //获取失败没有消息，继续下一次读取  \n                    continue;  \n                }  \n                //获取成功，解析订单消息  \n                MapRecord<String, Object, Object> entries = mapRecords.get(0);  \n                Map<Object, Object> value = entries.getValue();  \n                VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true);  \n                //创建订单  \n                handleVoucherOrder(voucherOrder);  \n                //ACK确认  \n                stringRedisTemplate.opsForStream().acknowledge(queueName, \"g1\", entries.getId());  \n            } catch (Exception e) {  \n                //出现异常时确认消息  \n                handlePendingList();  \n                log.error(\"订单处理异常\", e);  \n            }  \n        }  \n    }  \n}  \n  \nprivate void handlePendingList() {  \n    while (true) {  \n        try {  \n            //从消息队列中获取订单信息，创建订单  \n            List<MapRecord<String, Object, Object>> mapRecords = stringRedisTemplate.opsForStream().read(  \n                    //从哪一个组中读取  \n                    Consumer.from(\"g1\", \"c1\"),  \n                    //指定读取的数量并设置阻塞时间为2秒  \n                    StreamReadOptions.empty().count(1),  \n                    StreamOffset.create(queueName, ReadOffset.from(\"0\"))  \n            );  \n            //判断消息是否获取成功  \n            if (null == mapRecords || mapRecords.isEmpty()) {  \n                //获取失败没有消息，pendingLIst中没有异常消息，循环结束  \n               break;  \n            }  \n            //获取成功，解析订单消息  \n            MapRecord<String, Object, Object> entries = mapRecords.get(0);  \n            Map<Object, Object> value = entries.getValue();  \n            VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true);  \n            //创建订单  \n            handleVoucherOrder(voucherOrder);  \n            //ACK确认  \n            stringRedisTemplate.opsForStream().acknowledge(queueName, \"g1\", entries.getId());  \n        } catch (Exception e) {  \n            log.error(\"pendingList异常\", e);  \n            try {  \n                Thread.sleep(50);  \n            } catch (InterruptedException ex) {  \n                ex.printStackTrace();  \n            }  \n        }  \n    }  \n}\n```\n\n\n# 点评功能\n\n## 完善发布点评\n\n- 发布功能接口完善\n```java\n@Service  \npublic class BlogServiceImpl extends ServiceImpl<BlogMapper, Blog> implements IBlogService {  \n    @Resource  \n    private IUserService userService;  \n    @Override  \n    public Result queryHotBlog(Integer current) {  \n        // 根据用户查询  \n        Page<Blog> page =query()  \n                .orderByDesc(\"liked\")  \n                .page(new Page<>(current, SystemConstants.MAX_PAGE_SIZE));  \n        // 获取当前页数据  \n        List<Blog> records = page.getRecords();  \n        // 查询用户  \n        records.forEach(blog ->{  \n            userQuery(blog);  \n        });  \n        return Result.ok(records);  \n    }  \n  \n    private void userQuery(Blog blog) {  \n        Long userId = blog.getUserId();  \n        User user = userService.getById(userId);  \n        blog.setName(user.getNickName());  \n        blog.setIcon(user.getIcon());  \n    }  \n  \n    @Override  \n    public Result queryBlogById(Long id) {  \n        Blog blog = getById(id);  \n        if (blog==null){  \n            return Result.fail(\"不存在！！\");  \n        }  \n        //查询有关用户id,并封装数据  \n        userQuery(blog);  \n        return  Result.ok(blog);  \n    }  \n}\n```\n\n## 完善点赞功能实现\n\n- 同一个用户只能对一个点赞一次，再次单击取消点赞\n- 如果当前用户已经点赞，则点赞按钮高亮显示(前端通过判断blog类的isLike属性)\n\n\n实现步骤：\n1. 给blog类中添加一个isLike字段标识是否被当前用户点赞\n2. 利用redis的set集合判断是否点过赞，没有点赞数加1，有则数量减1\n3. 修改根据id查询blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段\n4. 修改分页查询blog业务，判断当前用户是否点赞过，复制给isLike字段\n\n\n- 添加字段，@TableField(exist = false)  注解表示不属于数据库表的字段\n```java\n/**  \n * 是否点赞过了  \n */  \n@TableField(exist = false)  \nprivate Boolean isLike;\n```\n\n\n\n```java\n@Service  \npublic class BlogServiceImpl extends ServiceImpl<BlogMapper, Blog> implements IBlogService {  \n    @Resource  \n    private IUserService userService;  \n  \n    @Resource  \n    private StringRedisTemplate stringRedisTemplate;  \n  \n    @Override  \n    public Result queryHotBlog(Integer current) {  \n        // 根据用户查询  \n        Page<Blog> page = query()  \n                .orderByDesc(\"liked\")  \n                .page(new Page<>(current, SystemConstants.MAX_PAGE_SIZE));  \n        // 获取当前页数据  \n        List<Blog> records = page.getRecords();  \n        // 查询用户  \n        records.forEach(blog -> {  \n            userQuery(blog);  \n            BlogIsLiked(blog);  \n        });  \n        return Result.ok(records);  \n    }  \n  \n    private void userQuery(Blog blog) {  \n        Long userId = blog.getUserId();  \n        User user = userService.getById(userId);  \n        blog.setName(user.getNickName());  \n        blog.setIcon(user.getIcon());  \n    }  \n  \n    @Override  \n    public Result queryBlogById(Long id) {  \n        Blog blog = getById(id);  \n        if (blog == null) {  \n            return Result.fail(\"不存在！！\");  \n        }  \n        //查询有关用户id,并封装数据  \n        userQuery(blog);  \n        //查询是否被点赞  \n        BlogIsLiked(blog);  \n        return Result.ok(blog);  \n    }  \n  \n    private void BlogIsLiked(Blog blog) {  \n        //获取当前用户  \n        Long usrId = UserHolder.getUser().getId();  \n        //判断用户是否已点赞  \n        String key = \"blog:liked:\" +  blog.getId();  \n        Boolean is_member = stringRedisTemplate.opsForSet().isMember(key, usrId.toString());  \n        blog.setIsLike(BooleanUtil.isTrue(is_member));  \n    }  \n  \n    @Override  \n    public Result likeBlog(Long id) {  \n        //获取当前用户  \n        Long usrId = UserHolder.getUser().getId();  \n        //判断用户是否已点赞  \n        String key = \"blog:liked:\" + id;  \n        Boolean is_member = stringRedisTemplate.opsForSet().isMember(key, usrId.toString());  \n        if (BooleanUtil.isFalse(is_member)) {  \n            //未点赞,点赞数加1  \n            boolean b = update().setSql(\"liked = liked + 1\").eq(\"id\", id).update();  \n            //保存用户到set集合  \n            if (b) {  \n                stringRedisTemplate.opsForSet().add(key, usrId.toString());  \n            }  \n        } else {  \n            //已点赞，点赞数减1  \n            boolean b = update().setSql(\"liked = liked - 1\").eq(\"id\", id).update();  \n            //blog中的set集合中移除当前用户  \n            if (b) {  \n                stringRedisTemplate.opsForSet().remove(key,usrId.toString());  \n            }  \n        }  \n  \n        return Result.ok();  \n    }  \n}\n```\n\n## 点赞排行\n\n- 按照点赞时间先后排序，返回前5个点赞的用户\n\n- 使用redis的==有序集合sorted set==，将点赞用户的时间作为分数(score)进行排序\n- 在判判断成员是否存在时，由于没有set集合中的==.isMember==方法进行判断，所以这里使用==.score==方法查询当前成员的排序分数，若用户不存在则返回空\n```java\n@Override  \npublic Result likeBlog(Long id) {  \n    //获取当前用户  \n    Long usrId = UserHolder.getUser().getId();  \n    //判断用户是否已点赞  \n    String key = \"blog:liked:\" + id;  \n    Double score = stringRedisTemplate.opsForZSet().score(key, usrId.toString());  \n    if (null == score) {  \n        //未点赞,点赞数加1  \n        boolean b = update().setSql(\"liked = liked + 1\").eq(\"id\", id).update();  \n        //保存用户到set集合  \n        if (b) {  \n            stringRedisTemplate.opsForZSet().add(key, usrId.toString(), System.currentTimeMillis());  \n        }  \n    } else {  \n        //已点赞，点赞数减1  \n        boolean b = update().setSql(\"liked = liked - 1\").eq(\"id\", id).update();  \n        //blog中的set集合中移除当前用户  \n        if (b) {  \n            stringRedisTemplate.opsForZSet().remove(key, usrId.toString());  \n        }  \n    }  \n  \n    return Result.ok();  \n}\n```\n\n```java\nprivate void BlogIsLiked(Blog blog) {  \n    //获取当前用户  \n    Long usrId = UserHolder.getUser().getId();  \n    //判断用户是否已点赞  \n    String key = \"blog:liked:\" + blog.getId();  \n    Double score = stringRedisTemplate.opsForZSet().score(key, usrId.toString());  \n    blog.setIsLike(null != score);  \n}\n```\n\n# 好友关注\n\n## 关注和取关接口实现\n\n```java\n@Service  \npublic class FollowServiceImpl extends ServiceImpl<FollowMapper, Follow> implements IFollowService {  \n  \n    @Override  \n    public Result follow(Long followId, Boolean isFollow) {  \n        Long usrID = UserHolder.getUser().getId();  \n        if (isFollow){  \n            //关注，新增数据  \n            Follow follow = new Follow();  \n            follow.setUserId(usrID);  \n            follow.setFollowUserId(followId);  \n            save(follow);  \n        }else {  \n            //取关，删除数据  \n            remove(new QueryWrapper<Follow>()  \n                    .eq(\"user_id\",usrID)  \n                    .eq(\"follow_user_id\",followId));  \n        }  \n        return Result.ok();  \n    }  \n  \n    @Override  \n    public Result isFollow(Long followId) {  \n        Long usrID = UserHolder.getUser().getId();  \n        Integer count = query().eq(\"user_id\", usrID)  \n                .eq(\"follow_user_id\", followId).count();  \n        return Result.ok(count>0);  \n    }  \n}\n```\n\n\n## 共同关注功能实现\n\n- 利用redis的set集合将用户关注的对象id和用户的id存入set集合\n- 当用户查看另一个用户的共同关注时，则查询两个用户之间的相同\n\n```java\n@Resource  \nprivate StringRedisTemplate stringRedisTemplate;  \n@Override  \npublic Result follow(Long followId, Boolean isFollow) {  \n    Long usrID = UserHolder.getUser().getId();  \n    String key = \"follow:\"+usrID;  \n    if (isFollow){  \n        //关注，新增数据  \n        Follow follow = new Follow();  \n        follow.setUserId(usrID);  \n        follow.setFollowUserId(followId);  \n        boolean isSuccess = save(follow);  \n        if (isSuccess){  \n            //将关注的用户id放入redis的set集合  \n        stringRedisTemplate.opsForSet().add(key,followId.toString());  \n        }  \n    }else {  \n        //取关，删除数据  \n        boolean isSuccess = remove(new QueryWrapper<Follow>()  \n                .eq(\"user_id\", usrID)  \n                .eq(\"follow_user_id\", followId));  \n        if (isSuccess){  \n            //将关注的用户id移出redis的set集合  \n            stringRedisTemplate.opsForSet().remove(key,followId.toString());  \n        }  \n    }  \n    return Result.ok();  \n}\n```\n- set集合的.intersect方法传入连个key，就可以查询两个key之间的交集\n\n```java\n@Override  \npublic Result followComment(Long id) {  \n    Long usrID = UserHolder.getUser().getId();  \n    //当前用户关注的集合的key  \n    String key = \"follow:\" + usrID;  \n    //要查询的用户关注集合的key  \n    String key2 = \"follow:\" + id;  \n    //set集合的.intersect方法传入连个key，就可以查询两个key之间的交集  \n    Set<String> intersect = stringRedisTemplate.opsForSet().intersect(key, key2);  \n    if (null == intersect || intersect.isEmpty()) {  \n        return Result.ok(Collections.emptyList());  \n    }  \n    //解析id，查询用户  \n    List<Long> collect = intersect.stream()  \n            .map(Long::valueOf)  \n            .collect(Collectors.toList());  \n    List<UserDTO> userDTOS = userService.listByIds(collect)  \n            .stream()  \n            .map(user ->  \n                    BeanUtil.copyProperties(user, UserDTO.class)  \n            ).collect(Collectors.toList());  \n    return Result.ok(userDTOS);  \n}\n```\n\n## 关注推送\n\n> 关注推送也叫做feed流，为用户持续的提供”沉浸式“的体验，通过无限下拉刷新获取新的信息\n\n## Feed流模式\nfeed流两种常见模式：\n1.  **TimeLine:** 不做内容筛选，简单的按照内容发布时间排序 \n- 优点：信息全面，不会有缺失，且实现简单\n- 缺点：信息噪音较多，内容获取效率低\n\n2. **智能排序：** 利用智能算法屏蔽掉违规，用户不感兴趣的内容，推送用户感兴趣的信息\n- 优点：用户黏度高\n- 缺点：需要高准确的算法\n\n<u>在这里使用TimeLine模式</u>\n\nTimeLine的实现方案也有三种：\n**1. 拉模式**\n- 也称为读扩散\n\n发消息的用户将带有时间戳的消息发送到发件箱，收消息的用户只有在读取消息时，才会将该用户关注的人发送的消息从发件箱拉取到该用户的收件箱，再将消息按时间排序。\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221022.15-53-49.png)\n\n\n优点：节省空间(只有读取消息时才，拉取消息到收件箱，收件箱的消息每次读取完毕后都会删除)\n缺点：耗时长，消息延迟高\n\n**2. 推模式**\n- 也称为写扩散\n\n发送消息的用户会直接将发送的消息推送到关注他的用户的收件箱内并按时间戳排序，收消息的人则直接读取收件箱内的消息\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221022.15-58-54.png)\n\n优点：消息延迟低\n缺点：占用空间大\n\n**3. 推拉结合** \n- 也称为读写混合，兼具推和拉两种模式的优点\n\n将发消息的人分为两种：\n1. 大V,粉丝数量多\n2. 普通人：粉丝数量少\n\n收消息的人也分为两种：\n1. 普通粉丝（查看消息频率一般）\n2. 狂热粉丝（查看消息频率高）\n\n- 当普通人发送消息时，由于粉丝少可以采取写模式，将发送的消息直接推送到少数粉丝的收件箱。\n- 当大v发送消息时，收消息的人多采取读模式，将消息发送到发件箱，收消息的人需要先从大V发件箱拉取消息到自己的收件箱再进行查看\n- 由于狂热粉丝查看消息频率高，所以当大v发送消息时直接将消息写到狂热粉丝的收件箱\n\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221022.16-08-51.png)\n\n\n\n\n\n\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221022.16-10-39.png)\n\n\n## 基于推模式实现关注推送消息功能\n\n- 修改新增点评的业务，在保存blog到数据库的同时，推送到粉丝的收件箱\n- 收件箱满足可以根据时间戳排序，必须使用redis的数据结构实现\n- 查询收件箱数据时，可以实现分页查询\n\n**feed流的分页问题:** feed流中的数据会不断更新，所以数据的角标也在变化，不能采取传统的分页模式\n\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221022.16-26-59.png)\n\n当用户在t1发送了10条消息时按时间排序，进行分页读取从“消息10“到”消息6“，但是在t2时刻发布了新的消息11，按照时间排序，消息11将排在最后面，t3时刻进行分页读取第二页的内容时将会从消息6开始读取，造成消息重复读取\n\n**feed流的滚动分页：** \n\n![](https://7601.oss-cn-hangzhou.aliyuncs.com/noteImg/20221022.16-32-05.png)\n\n\n第一次将分页读取的id指定为无穷大或当前时间戳，下一次查询lastid为上一次的最小值为消息6，当t2发布新内容后，将会从消息6开始分页避免了消息重复读取\n\nlist集合只能根据角标查询不支持滚动分页，所以这里使用redis的有序集合作为收件箱，利用有序集合的score进行查询\n\n- **对原来的保存点评功能进行修改，并实现推送消息到粉丝redis有序集合收件箱**\n\n```java\n@Override  \npublic Result saveBlog(Blog blog) {  \n    // 获取登录用户  \n    Long usrId = UserHolder.getUser().getId();  \n    blog.setUserId(usrId);  \n    // 保存探店博文  \n    boolean isSuccess = save(blog);  \n    if (!isSuccess){  \n        return Result.fail(\"新增点评失败\");  \n    }  \n    //查询发送消息人的所以粉丝  \n    List<Follow> follows = followService.query().eq(\"follow_user_id\", usrId).list();  \n    //推送blog的id给所有粉丝  \n    long timeMillis = System.currentTimeMillis();  \n    for (Follow follow : follows) {  \n        //获取粉丝id  \n        Long userId = follow.getUserId();  \n        //推送  \n        String key = \"feed:\" + userId;  \n        stringRedisTemplate.opsForZSet().add(key,blog.getId().toString(),timeMillis);  \n    }  \n    // 返回id  \n    return Result.ok(blog.getId());  \n}\n```\n\n## 实现关注推送页面的分页查询\n\n**滚动查询的参数：**\n1. max:  上一次查询的最小时间戳（第一次查询时设为当时间戳）\n2. min: 0（固定为0）\n3. offset: 在上一次的结果中，与最小值一样的元素个数（第一次查询时设置为0）\n4. count: 3（根据前端要求设置数量）\n\n- 第一次分页查询的请求：\n\\http://localhost:8080/api/blog/of/follow?&lastId=1666430380422\n\n请求参数：\n1. lastId：上一次查询的最小时间戳\n2. offset：偏移量\n\n返回值：\n1. List\\<Blog>：小于指定时间戳的点评集合\n2. minTime：本次查询的推送的最小时间戳\n3. offset：偏移量\n\n- 定义返回的数据DTO\n\n```java \n@Data  \npublic class ScrollResult {  \n    private List<?> list;  \n    private Long minTime;  \n    private Integer offset;  \n}\n```\n\n- 分页方法的实现\n\n```java\n@Override  \npublic Result pageFollow(Long max, Integer offset) {  \n    //查询当前用户的收件箱  \n    Long usrId = UserHolder.getUser().getId();  \n    String key = RedisConstants.FEED_KEY + usrId;  \n    //查询收件箱 ZREVRANGEBYSCORE key Max Min LIMIT offset count    Set<ZSetOperations.TypedTuple<String>> typedTupleSet = stringRedisTemplate.opsForZSet()  \n            .reverseRangeByScoreWithScores(key, 0, max, offset, 2);  \n    if (null==typedTupleSet||typedTupleSet.isEmpty()){  \n        return Result.ok();  \n    }  \n    //解析数据：blogId ，score(时间戳) , offset  \n    List<Long> idList = new ArrayList<>(typedTupleSet.size());  \n    long minTime = 0;  \n    int OS = 1;  \n    for (ZSetOperations.TypedTuple<String> stringTypedTuple : typedTupleSet) {  \n        //获取id  \n        String  id = stringTypedTuple.getValue();  \n        idList.add(Long.valueOf(id));  \n        //获取时间戳  \n        long time = stringTypedTuple.getScore().longValue();  \n        if (minTime==time){  \n            OS++;  \n        }else {  \n            minTime = time;  \n            OS = 1;  \n        }  \n    }  \n    //根据id查询blog  \n    String  idStr = StrUtil.join(\",\", idList);  \n    List<Blog> blogs = query().in(\"id\", idList)  \n            .last(\"ORDER BY FIELD (id,\" + idStr + \") \").list();  \n    for (Blog blog : blogs) {  \n        //查询有关用户id,并封装数据  \n        userQuery(blog);  \n        //查询是否被点赞  \n        BlogIsLiked(blog);  \n    }  \n    //封装数据返回  \n    ScrollResult scrollResult = new ScrollResult();  \n    scrollResult.setList(blogs);  \n    scrollResult.setOffset(OS);  \n    scrollResult.setMinTime(minTime);  \n    return Result.ok(scrollResult);  \n}\n```\n\n\n\n\n# 附近商户\n\n\n## GEO数据结构\n\nGeolocation，表示地理坐标。redis在3.2版本中加入了对GEO的支持，允许储存地理坐标信息，可以根据经纬度来检索数据\n\n**常见命令：**\n- GEOADD：添加一个地理空间信息(经度，纬度，值)\n- GEODIST：计算指定的两个点之间的距离并返回\n- GEOHASH：将指定member的坐标转为hash字符串形式并返回\n- GEOPOS：返回指定member的坐标\n- GEORADIUS：指定圆心半径，找到该园内包含的所有member，并安装与圆心之间的距离排序后返回，6.2后已废弃\n- GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形，6.2新功能\n- GEOSEARCHSTORE：与GEOSEARCH功能一致，但可以将结果储存到一个指定的key，6.2新功能\n\n\n## 附近商户搜索\n\n### 导入店铺GEO数据\n\n- 将原有店铺数据导入到redisGEO中，保存店铺typeID，经纬度\n```java\n   //添加数据  \n    @Resource  \n    private StringRedisTemplate stringRedisTemplate;  \n  \n    @Test  \n    void addData() {  \n        //查询店铺信息  \n        List<Shop> shopList = shopService.list();  \n        //将typeId一致的店铺分为一个组  \n        Map<Long, List<Shop>> collect = shopList.stream().collect(Collectors.groupingBy(shop -> {  \n            return shop.getTypeId();  \n        }));  \n        //分批写入redis  \n        for (Map.Entry<Long, List<Shop>> longListEntry : collect.entrySet()) {  \n            //获取类型id  \n            Long type = longListEntry.getKey();  \n            String key = \"shop:geo:\" + type;  \n            //获取同类型的店铺集合  \n            List<Shop> value = longListEntry.getValue();  \n            //直接利用循环将店铺id 经纬度存入redis  \n//            for (Shop shop : value) {  \n//                stringRedisTemplate.opsForGeo()  \n//                        .add(key,  \n//                             new Point(shop.getX(),shop.getY()), //坐标点  \n//                             shop.getId().toString());//店铺id  \n//            }  \n            //先存入List<RedisGeoCommands.GeoLocation<String>>集合中再统一写入redis，可以提高速度  \n            List<RedisGeoCommands.GeoLocation<String>> locations = new ArrayList<>(value.size());  \n            for (Shop shop : value) {  \n                locations.add(  \n                        new RedisGeoCommands.GeoLocation<>(  \n                                shop.getId().toString(),  \n                                new Point(shop.getX(),  \n                                        shop.getY())));  \n                stringRedisTemplate.opsForGeo().add(key, locations);  \n            }  \n        }  \n    }\n```\n\n\n### 进行修改\n\n- **注意：**\n>由于本项目使用的springboot不是最新版本，所以spring-boot-starter-data-redis内的spring-data-redis版本无法使用GEOSEARCH命令。这里将spring-boot-starter-data-redis内的spring-data-redis去除，再手动添加最新的依赖\n\n\n```xml\n        <dependency>  \n            <groupId>org.springframework.boot</groupId>  \n            <artifactId>spring-boot-starter-data-redis</artifactId>  \n<!--            去除旧版本的spring-data-redis和lettuce-->  \n            <exclusions>  \n                <exclusion>                    \n                <groupId>org.springframework.data</groupId>  \n                <artifactId>spring-data-redis</artifactId>  \n                </exclusion>\n            <exclusion>                   \n                <groupId>io.lettuce</groupId>  \n                <artifactId>lettuce-core</artifactId>  \n                </exclusion>            \n            </exclusions>        \n        </dependency> \n        <!-- 添加最新的spring-data-redis -->\n        <dependency>            \n            <groupId>org.springframework.data</groupId>  \n            <artifactId>spring-data-redis</artifactId>  \n            <version>2.6.2</version>  \n        </dependency>\n        <!-- 添加最新的lettuce -->\n        <dependency> \n            <groupId>io.lettuce</groupId>  \n            <artifactId>lettuce-core</artifactId>  \n            <version>6.1.6.RELEASE</version>  \n        </dependency>\n```\n\n**controller改造：**\n```java\n@GetMapping(\"/of/type\")  \npublic Result queryShopByType(  \n        @RequestParam(\"typeId\") Integer typeId,  \n        @RequestParam(value = \"current\", defaultValue = \"1\") Integer current,  \n        //坐标参数不一定会有，所以这里设置required = false  \n        @RequestParam(value = \"x\",required = false) Double x,  \n        @RequestParam(value = \"y\",required = false) Double y  \n) {  \n    return  shopService.queryShopById(typeId,current,x,y);  \n}\n```\n\n\n**Servercie方法实现：**\n\n```java\n@Override  \npublic Result queryShopById(Integer typeId, Integer current, Double x, Double y) {  \n    //先判断是否需要按坐标进行查询  \n    if (null == x || null == y) {  \n        //不需要坐标查询，直接从数据库查询  \n        // 根据类型分页查询  \n        Page<Shop> page = query()  \n                .eq(\"type_id\", typeId)  \n                .page(new Page<>(current, SystemConstants.DEFAULT_PAGE_SIZE));  \n        // 返回数据  \n        return Result.ok(page.getRecords());  \n    }  \n    //计算分页参数  \n    int from = (current - 1) * SystemConstants.DEFAULT_PAGE_SIZE;  \n    int end = current * SystemConstants.DEFAULT_PAGE_SIZE;  \n    //查询redis按照距离排序，分页。 返回数据：shopID 距离distance  \n    String key = \"shop:geo:\"+typeId;  \n  \n    GeoResults<RedisGeoCommands.GeoLocation<String>> geoResults = stringRedisTemplate.opsForGeo().search(  \n            key,  \n            GeoReference.fromCoordinate(x, y),  \n            new Distance(5000),  \n            //设置带上距离单位  \n            RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance()  \n                    //设置查询的个数，每次都从0开始查询  \n                    .limit(end)  \n    );  \n    //解析id查询shop  \n    if (null==geoResults){  \n        return Result.ok(Collections.emptyList());  \n    }  \n  \n    List<GeoResult<RedisGeoCommands.GeoLocation<String>>> geoResultsContent = geoResults.getContent();  \n//截取数据，从form到end结束  \n  \n    if (geoResultsContent.size()<=from){  \n        //查询到了数据的最后一页，后面没有数据了  \n        return  Result.ok(Collections.emptyList());  \n    }  \n  \n    //创建list集合收集id  \n    List<Long> idList = new ArrayList<>(geoResultsContent.size());  \n  \n    //保存距离的map集合  \n    Map<String,Distance> distanceMap = new HashMap<>();  \n    geoResultsContent.stream().skip(from).forEach(  \n            result ->{  \n                //获取店铺id  \n                String idStr = result.getContent().getName();  \n                idList.add(Long.valueOf(idStr));  \n                //获取距离  \n                Distance distance = result.getDistance();  \n                distanceMap.put(idStr,distance);  \n            }  \n    );  \n    //根据id查询shop  \n    String ids = StrUtil.join(\",\", idList);  \n    List<Shop> shopList = query().  \n            in(\"id\", idList).  \n            last(\"ORDER BY FIELD(id,\" + ids + \")\").  \n            list();  \n    for (Shop shop : shopList) {  \n        shop.setDistance(  \n                distanceMap.get(shop.getId().toString()).  \n                getValue());  \n    }  \n  \n    return Result.ok(shopList);  \n}\n```\n\n\n\n\n# 用户签到\n\n## redis中bitmap的用法\n\n- 基本原理\n>BitMap 的基本原理就是用一个 bit 来标记某个元素对应的 Value，而 Key 即是该元素。由于采用一 个bit 来存储一个数据，因此可以大大的节省空间。\n\n**redis**利用string类型数据结构实现bitmap，因此最大上限是512M\n\n**redis中bitmap的操作命令有：**\n- SETBIT：向指定位置存入一个0或1\n- GETBIT：获取指定位置的bit值\n- BITCOUNT：统计bitmap中值为1的bit位的数量\n- BITFIELD：操作（查询，修改，自增）bitmap中bit数组中的指定位置的值\n- BITFIELD_OR：获取bitmap中bit数组，并以10进制形式返回\n- BITOP：将多个bitmap的结果做位运算(与，或，异或)\n- BITPOS：查找bit数组中指定范围内第一个0或1出现的位置\n\n## 签到功能\n\n- 将当前用户当天签到信息保存到redis中\n- bitmap底层是基于string数据结构，redis对bitmap的操作也都封装在字符串相关操作中\n\n实现签到功能\n```java\n@Override  \npublic Result sign() {  \n    //获取当前用户  \n    Long id = UserHolder.getUser().getId();  \n    //获取日期  \n    LocalDateTime dateTime = LocalDateTime.now();  \n    //拼接key  \n    String  keySuffix = dateTime.format(DateTimeFormatter.ofPattern(\"yyyyMM\"));  \n    String key = RedisConstants.USER_SIGN_KEY + id + keySuffix;  \n    //获取今天是本月的第几天  \n    int day = dateTime.getDayOfMonth();  \n    //写入redis  \n    stringRedisTemplate.opsForValue().setBit(key,day-1,true);  \n    return Result.ok();  \n}\n```\n## 签到统计\n- 统计连续签到的次数\n\n- 通过将bitmap中的数据与1进行与运算来得到最后一个bit位\n\n```java\n@Override  \npublic Result signCount() {  \n    //获取当前用户  \n    Long id = UserHolder.getUser().getId();  \n    //获取日期  \n    LocalDateTime dateTime = LocalDateTime.now();  \n    //拼接key  \n    String  keySuffix = dateTime.format(DateTimeFormatter.ofPattern(\"yyyyMM\"));  \n    String key = RedisConstants.USER_SIGN_KEY + id + keySuffix;  \n    //获取今天是本月的第几天  \n    int day = dateTime.getDayOfMonth();  \n    //获取本月截至今天所有的签到记录,返回的是一个10进制数字  \n    List<Long> bitField = stringRedisTemplate.opsForValue().bitField(  \n            key,  \n            BitFieldSubCommands.  \n                    create().                get(BitFieldSubCommands.BitFieldType.unsigned(day)).valueAt(0)  \n    );  \n    if (null==bitField||bitField.isEmpty()){  \n        return Result.ok(Collections.emptyList());  \n    }  \n    //由于确定bitField内只有一个值所以直接取出  \n    Long aLong = bitField.get(0);  \n    if (null==aLong||0==aLong){  \n        return Result.ok(0);  \n    }  \n    //遍历循环  \n    int count = 0;//计数器  \n    while (true){  \n        //与1做与运算得到数字的最后一个bit位,并判断这个bit位是否位0  \n        if ((aLong & 1)==0){  \n         //未签到,结束  \n            break;  \n        }else {  \n           count++;  \n        }  \n        //将数字右移1位，抛弃最后一个bit位，继续下一个bit位  \n        aLong >>>= 1;  \n    }  \n  \n    return  Result.ok(count);  \n}\n```\n\n\n# UV统计\n\n- UV（Unique Vistor）**独立访客量**，指通过互联网访问，浏览这个网页的自然人。1天内统一个用户多次访问该网站，只记录一次\n- PV （Page View）**页面访问量或点击量**，用户每访问网站的一个页面，记录1次PV，多次打开页面则记录多次PV\n\n# Redis HyperLogLog\n\nRedis 在 2.8.9 版本添加了 HyperLogLog 结构。\n\nRedis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。\n\n在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。\n\n但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。\n\n---\n\n## 什么是基数?\n\n比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。\n\n---\n\n## 实例\n\n以下实例演示了 HyperLogLog 的工作过程：\n\n```bash\nredis 127.0.0.1:6379> PFADD runoobkey \"redis\"\n1) (integer) 1\n```\n\n```bash\nredis 127.0.0.1:6379> PFADD runoobkey \"mongodb\"\n1) (integer) 1\n```\n\n```bash\nredis 127.0.0.1:6379> PFADD runoobkey \"mysql\"\n1) (integer) 1\n```\n\n```bash\nredis 127.0.0.1:6379> PFCOUNT runoobkey\n(integer) 3\n```\n\n## Redis HyperLogLog 命令\n\n下表列出了 redis HyperLogLog 的基本命令：\n\n|      | 命令及描述                                                   |      |\n| ---- | ------------------------------------------------------------ | ---- |\n| 1    | [PFADD key element [element ...]](https://www.runoob.com/redis/hyperloglog-pfadd.html)添加指定元素到 HyperLogLog 中。 |      |\n| 2    | [PFCOUNT key [key ...]](https://www.runoob.com/redis/hyperloglog-pfcount.html) 返回给定 HyperLogLog 的基数估算值 |      |\n| 3    | [PFMERGE destkey sourcekey [sourcekey ...]](https://www.runoob.com/redis/hyperloglog-pfmerge.html)将多个 HyperLogLog 合并为一个 HyperLogLog |      |\n\n\n\n# 项目完整代码\n\n[itheima-hmdp: 学习redis的黑马点评案例 (gitee.com)](https://gitee.com/seven601/itheima-hmdp)\n\n\n\n[^atomicity]:指事务的不可分割性，一个事务的所有操作要么不间断地全部被执行，要么一个也没有执行。","tags":["redis","java"],"categories":["notes"]},{"title":"more","path":"/more/index.html","content":"# 测试..."}]